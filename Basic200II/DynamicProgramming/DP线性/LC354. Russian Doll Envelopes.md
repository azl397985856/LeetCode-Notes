## LC 354. Russian Doll Envelopes

https://leetcode-cn.com/problems/russian-doll-envelopes/

- [动态规划二刷06/09/2021](#思路-动态规划二刷06/09/2021)
- [动态规划](#思路-动态规划)

### 思路 动态规划二刷06/09/2021
动态规划 - 线性 - 单串
#### 代码 JavaScript

```JavaScript
var maxEnvelopes = function(envelopes) {
    envelopes.sort((a,b) => {
        if(a[0] == b[0]){
            return a[1] - b[1]
        }else{
            return a[0] - b[0]
        }
    })

    //dp[i] 以 i 结尾，必须选i的时候的最长升序子序列
    //注意ret 要初始化为1  不然 envelopes.length = 1 的时候会报错
    let ret = 1
    const dp = new Array(envelopes.length).fill(1)
    dp[0] = 1
    for(let i = 1; i < envelopes.length; i++){
        for(let j = 0; j < i; j++){
            if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]){
                dp[i] = Math.max(dp[j] + 1, dp[i])
            }
        }
        ret = Math.max(ret, dp[i])
    }

    return ret

};

```

#### 复杂度分析
时间复杂度： </br>
空间复杂度：

### 思路 动态规划

最长上升子序列换皮

#### 代码 JavaScript

```JavaScript
var maxEnvelopes = function(envelopes) {
    //最长上升子序列 换皮

    envelopes.sort((a,b) => a[0] - b[0])

    //dp[i]表示一定选这个i的时候 最长上升子序列的值

    //这里的ans注意如果要单独拿出来的话，应该是从1开始的，因为最少是一个

    let ans = 1

    const dp = new Array(envelopes.length).fill(1)

    for(let i = 0; i < envelopes.length; i++){
        for(let j = 0; j < i; j++){
            if(envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]){
                dp[i] = Math.max(dp[i], dp[j] + 1)
                ans = Math.max(dp[i], ans)
            }
        }
    }

    return ans;
};

```

#### 复杂度分析

时间复杂度：O(N^2) </br>
空间复杂度：O(N)
