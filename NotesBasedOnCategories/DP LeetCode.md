## Dynamic Programming - 阅读LC动态规划精讲笔记

### 简介
解决动态规划问题的核心：找出子问题及其子问题与原问题的关系

找到了子问题以及子问题与原问题的关系，就可以递归地求解子问题了。但重叠的子问题使得直接递归会有很多重复计算，于是就想到记忆化递归法：若能事先确定子问题的范围就可以建表存储子问题的答案。

动态规划算法中关于最优子结构和重复子问题的理解的关键点：
1. 证明问题的方案中包含一种选择，选择之后留下一个或多个子问题
2. 设计子问题的递归描述方式
3. 证明对原问题的最优解包括了对所有子问题的最优解
4. 证明子问题是重叠的（这一步不是动态规划正确性必需的，但是如果子问题无重叠，则效率与一般递归是相同的）

动态规划和分治的区别  
分治和动态规划都存在最优子结构，但是分治不存在重复子问题。

动态规划和贪心的对比  
1. 最优子结构  
贪心：每一步的最优解一定包含上一步的最优解，上一步的最优解无需记录。  
DP：全局最优解中一定包含某个局部最邮件，但不一定包含上一步的局部最优解，因此需要记录之前所有的局部最优解。  

2. 把子问题最优解组合成原问题最优解的组合方式  
贪心：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下遍历最优子树即可，这里的最优是贪心意义上的最优。此时不需要知道一个节点的所有子树情况，于是构不成一棵完整的树
动态规划：动态规划需要对每一个子树求最优解，直至下面的每一个叶子的值，最后得到一棵完整的树，在所有子树都得到最优解后，将他们组合成答案

3. 结果正确性
贪心不能保证求得的最后解是最佳的，复杂度低
动态规划本质是穷举法，可以保证结果是最佳的，复杂度高

|               | 分治           | 动态规划  |贪心        |
| ------------- |-------------| -----|--------------|
| 适用类型      | 通用 | 优化 |优化      |
| 子问题     | 每个都不同      |   有很多重复 | 只解一个最优的     |
| 最优子结构 |没有要求     |    必须满足 | 必须满足      |
| 子问题数 |全部都要解，穷举     |    全部都要解，穷举 | 只解一个      |
### 思考过程
1. 考虑能否将问题规模减小
一些典型的减小方式是动态规划分类的依据，比如线性，区间，树形等。
数组常用两种思路：减少一半（binary search）， 减少一个（DP，记忆化递归）

### key factors

状态：定义子问题  
枚举  
转移方程（选择）：子问题之间的关系  

### 背景：递归
一个递归问题有以下特点：  
1. 一个问题可以分解成具有相同解决思路的子问题，解决这些子问题都能调用同一个函数。
2. 分解子子子问题之后一定有一个固定值（递归终止条件）。

递归解题思路：  
1. 定义 + 明确一个函数 ： 一个子问题和这个问题都能一直调用的函数
注：这个函数不一定符合dp的定义
2. 递推公式： 寻找问题和子问题之间的关系
3. 寻找临界条件： 就是不可再分解的子问题，也是从递开始归的地方
4. 如果复杂度太高，换成dp


### 线性动态规划
线性动态规划的主要特点是状态的推导是按照问题规模 i 从小到大依次推过去的，较大规模的问题的解依赖较小规模的问题的解。

#### 线性动态规划一：单串
输入是一个串， 状态定义为 `dp[i] := 考虑[0..i]上问题的解`。其中i的处理方式可以是：  
1. 必取 i
2. 可取可不取

#### 经典题型
1. `dp[n]`依赖比i小的O(1)问题  
状态一般是 `dp[n] = f(dp[n-1], dp[n-2]...)`  
空间是O(N), 但是可以滚动数组优化到O(1)
例如，当 f(dp[i-1], ...) = dp[i-1] + nums[i] 时，当前状态 dp[i] 仅与 dp[i-1] 有关。这个例子是一种数据结构前缀和的状态计算方式。  
例题：70,81,790,746

2. `dp[n]`依赖比i小的O(N)个子问题   
在计算当前`dp[n]`的时候，此前计算过的状态`dp[i-1], ..., dp[0]`都有可能用到，在计算`dp[n]`的时候要遍历一遍它们。  
例题：139, 818  
```
for i = 1, ..., n
    for j = 1, ..., i-1
        dp[i] = min(dp[i], f(dp[j])
```
#### 线性动态规划二：带维度单串
#### 线性动态规划三：双串
#### 线性动态规划四：矩阵